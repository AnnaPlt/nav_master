#!/usr/bin/env python3
import casadi
from casadi import *
import do_mpc
import numpy as np
from geometry_msgs.msg import PoseStamped
from nav_msgs.msg import Path
from tf.transformations import euler_from_quaternion

class MPCUtil:
    def __init__(self):
        self.vel_v_max_p    =  0.2
        self.vel_v_max_n    =  0.01

        self.vel_w_max_p    =  0.3
        self.vel_w_max_n    = -0.3

        # Radius of the weelchair
        self.radius = 6.9 # [m]

        # Number of steps
        self.n_horizon = 60

        # The parameters of the cost functions
        self.Qx     = np.array([3,3,0, 2.2])
        self.QxN    = np.array([140,140,1, -1])

        # The weigth that lead the mpc to give discrete output
        self.Cp     = np.array([-1e-3,1e-1])
        # The "difficulty" of changig the input
        self.R      = np.array([1e-2,5e-4]) 

    def get_model(self, Ts):
        ## Create the model needed to evaluate mpc controller
        # The discret model used for command generate the mpc is:
        #
        # x[k+1]     = x[k] + v[k] * cos(theta[k]) * Ts
        # y[k+1]     = y[k] + v[k] * sin(theta[k]) * Ts
        # theta[k+1] = theta[k+1] + w [k] * Ts
        # v[k]       = v[k] + vacc[k]
        # w[k]       = w[k] + wacc[k]
        #
        # Where the vacc and w acc will be the input generated by the mpc in order to command the robot 
        # In this way the input is decoupled from the current state of the system (easier calculation)
        
        model_type = "discrete"
        model = do_mpc.model.Model(model_type)

        x     = model.set_variable(var_type='_x', var_name='x', shape=(1,1))
        y     = model.set_variable(var_type='_x', var_name='y', shape=(1,1))
        theta = model.set_variable(var_type='_x', var_name='theta', shape=(1,1))

        v     = model.set_variable(var_type='_x', var_name='v', shape=(1,1))
        w     = model.set_variable(var_type='_x', var_name='w', shape=(1,1))

        vacc     = model.set_variable(var_type='_u', var_name='vacc')
        wacc     = model.set_variable(var_type='_u', var_name='wacc')

        # Setup the variables update function
        f_1 = vertcat( x + v * cos(theta  ) * Ts )
        f_2 = vertcat( y + v * sin(theta ) * Ts )

        model.set_rhs('x', f_1)
        model.set_rhs('y', f_2)
        model.set_rhs('theta', theta + w * Ts)

        f_v = vertcat( v + vacc * Ts )
        f_w = vertcat( w + wacc * Ts )

        model.set_rhs('v', f_v)
        model.set_rhs('w', f_w)

        # Setup and return the model
        model.setup()

        return model
    


    def configure_mpc_controller(self, model, goal, Ts, obstacles):

        mpc = do_mpc.controller.MPC(model)

        # Setup parameters
        setup_mpc = {
            'n_horizon': self.n_horizon,
            't_step': Ts,
            'store_full_solution': True,
            'state_discretization': 'discrete',
        }
        mpc.set_param(**setup_mpc)

        # Soppres the output of the controller 
        suppress_ipopt = {'ipopt.print_level':0, 'ipopt.sb': 'yes', 'print_time':0}
        mpc.set_param(nlpsol_opts = suppress_ipopt)

        # Setup the cost function
        mterm = self.QxN[0] * (model._x['x'] - goal[0])**2 + self.QxN[1] * (model._x['y'] - goal[1])**2 + \
                self.QxN[2] * np.sin((model._x['theta'] - goal[2]))**2  + \
                self.QxN[3] * self.get_distance_components(model._x['x'],model._x['y'],obstacles, self.radius)

        lterm = self.Qx[0] * (model._x['x'] - goal[0])**2 + self.Qx[1] * (model._x['y'] - goal[1])**2 + \
                self.Qx[2] * np.sin((model._x['theta'] - goal[2]))**2 + \
                self.Qx[3] * self.get_distance_components(model._x['x'], model._x['y'], obstacles, self.radius) + \
                self.Cp[0] * model.x['v'] 


        mpc.set_objective(mterm=mterm, lterm=lterm)
        mpc.set_rterm( vacc=self.R[0], wacc=self.R[1] )

        # Lower bounds on inputs:
        mpc.bounds['lower','_x', 'v']     = self.vel_v_max_n
        mpc.bounds['lower','_x', 'w']     = self.vel_w_max_n
        # Lower bounds on inputs:
        mpc.bounds['upper','_x', 'v']     = self.vel_v_max_p
        mpc.bounds['upper','_x', 'w']     = self.vel_w_max_p
        
        # Setup and return the mpc controller
        mpc.setup()

        return mpc


    def get_controller(self, goal, Ts, model, obstacles, odom):
        new_controller = self.configure_mpc_controller(model, goal, Ts, obstacles)

        print("destination:      " +str(goal))
        print("current position: " +str(odom))

        new_controller.x0 = odom
        new_controller.set_initial_guess()

        return new_controller


    def convert_pose_data_to_state(self, pose:PoseStamped):
        x = np.array([0.0,0.0,0.0,0.0,0.0])

        x[0] = pose.pose.position.x
        x[1] = pose.pose.position.y

        ql = [ pose.pose.orientation.x, pose.pose.orientation.y, pose.pose.orientation.z, pose.pose.orientation.w ]
        x[2] = euler_from_quaternion(ql)[2]

        return x


    def get_local_plan(self, data, frame_id):
        data_x  = data.prediction(('_x','x',0),-1)[0,:,0]
        data_y  = data.prediction(('_x','y',0),-1)[0,:,0]
        data_th = data.prediction(('_x','theta',0),-1)[0,:,0]

        set = []
        for i in range(0,len(data_x)):
            
            ps = PoseStamped()
            ps.header.frame_id = frame_id
            ps.pose.position.x = data_x[i]
            ps.pose.position.y = data_y[i]
            ps.pose.orientation.w = 1.0
            set.append(ps)

        p = Path()
        p.header.frame_id = frame_id
        p.poses = set

        return p



    def sigmoid(self, x, s=1, t= 1):
        return 1 / ( 1 + casadi.exp( - s * ( x - t) ) ) 


    def get_distance_components(self, x,y, set_of_objects, radius = 2.5):
        
        function = 0
        eps = 0

        for i in set_of_objects:
            #gx = gaussian(x,eps,i[0]) 
            #gy = gaussian(y,eps,i[1]) 
            #function = function + (gx * gy)
            #print(function)
            function = function + radius/((casadi.sqrt((x-i[0] + eps)**2 + (y-i[1] + eps)**2 )  ) + eps)

        # Compute the sigmoiud of thefunction to smoot the peaks
        # 4 -> is to map 1->1
        s = self.sigmoid(  function , 1 , 0 )
            
        return s    #modificato da function a s

    def gg(self, x, alpha, r):
        return casadi.exp(-((x - r)**2)/(2*alpha))

    def gaussian(self, x, alpha, r):
        return  self.gg(x, alpha, r) / (casadi.sqrt(2*alpha*np.pi)) 
        
